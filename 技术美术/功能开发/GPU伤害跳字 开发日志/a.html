<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="uwa-lesson-detail-wrap"><h2 class="title">2｜实现思路</h2><div id="imgBox" class="article-wrap md-style"><h3>DOTS部分数据结构</h3><p></p><pre class="hljs LUA">public class CombatTextAuthoring : MonoBehaviour<br>{<br>    private class CombatTextAuthoringBaker : Baker&lt;CombatTextAuthoring&gt;<br>    {<br>        public override void Bake(CombatTextAuthoring authoring)<br>        {<br>            var entity = GetEntity(TransformUsageFlags.None);<br>            AddComponent(entity, typeof(CombatTextTag));<br>            AddComponent(entity, typeof(TextTRS));<br>            AddComponent(entity, new DestroyTimer{autoDestroy = <span class="hljs-number">1</span>});<br>        }<br>    }<br>}<br>
        public struct CombatTextTag : IComponentData<br>{<br>}<br>
        public struct TextTRS : IComponentData<br>{<br>    public uint4x4 uvVexIdx; // 顶点和uv下标<br>    public float2 scale; // 缩放<br>    public float2 wpos; // 世界坐标<br>}<br>
        /// &lt;summary&gt;<br>/// 自动销毁组件<br>/// &lt;/summary&gt;<br>public struct DestroyTimer : IComponentData<br>{<br>    public double fixedTime;// 开始时间戳<br>    public float duration;// 持续时间<br>    public <span class="hljs-built_in">byte</span> autoDestroy; // <span class="hljs-number">0</span>关闭自动销毁 <span class="hljs-number">1</span>开启自动销毁<br>}<br>
        public enum DamageStyle : <span class="hljs-built_in">byte</span><br>{<br>    Normal, // 伤害<br>    Health, // 恢复生命<br>    Crit, // 暴击<br>    Mana // 恢复法力<br>}</pre><p></p><p>把一个伤害数字作为一个Entity，Entity有TextTRS、DestroyTimer和CombatTextTag三个组件。</p><p></p><p>TextTRS：伤害数字的渲染数据，每个伤害一个buffer，该数据最终会发送到Shader的infoBuffer中。</p><p></p><p>DestroyTimer：播放完伤害数字动画后销毁该Entity。</p><p></p><p>CombatTextTag：tag</p><p></p><p>DamageStyle的4种类型对应4种文本风格。</p><p></p><div class="media-wrap image-wrap"><img class="media-wrap image-wrap" alt="loading" title="UWA" src="//videos2.uwa4d.com/1.1729492939153.png" width="500px" style="width:500px"></div><p></p><p></p><h3>Shader的数据结构</h3><p></p><pre class="hljs C#">            <span class="hljs-keyword">struct</span> appdata<br>            {<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>                <span class="hljs-keyword">uint</span> vid : SV_VertexID;<br>                UNITY_VERTEX_INPUT_INSTANCE_ID<br>            };<br>
                    <span class="hljs-keyword">struct</span> v2f<br>            {<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>                UNITY_VERTEX_INPUT_INSTANCE_ID<br>                UNITY_VERTEX_OUTPUT_STEREO<br>            };<br>
                    <span class="hljs-keyword">struct</span> TextTRS<br>            {<br>                uint4x4 uvVexIdx;<br>                float2 scale;<br>                float2 wpos;<br>            };<br>
                    StructuredBuffer&lt;TextTRS&gt; infoBuffer;<br>            StructuredBuffer&lt;float2&gt; textUvs;<br>            StructuredBuffer&lt;float2&gt; textVets;</pre><p></p><p>textUv和textVets：Font的每个字符的uv和顶点数据储存在这里。</p><p></p><p>infoBuffer：上面的DOTS数据结构已经解释过。</p><p></p><p></p><p><strong>结合上述的数据结构看，具体实现思路是：</strong></p><p>将每种类型数字的uv和顶点数据依次按顺序写入到textUv和textVets数组里。</p><p></p><div class="media-wrap image-wrap"><img class="media-wrap image-wrap" alt="loading" title="UWA" src="//uwa-edu.oss-cn-beijing.aliyuncs.com/2.1729493020254.png" width="500px" style="width:500px"></div><p></p><p>由于是按顺序写入的，因此读取的时候就可以根据DamageStyle和数值读取到对应的uv和顶点，例如：要读取DamageStyle.Crit风格的数字3的uv数据可以这么写：</p><p></p><pre class="hljs C#">byte number = <span class="hljs-number">3</span>;<br>byte styleIndex = (<span class="hljs-keyword">byte</span>)DamageStyle.Crit;<br>int index = styleIndex * <span class="hljs-number">40</span> + number * <span class="hljs-number">4</span>;<br>
        float2 uvTL = textUv[index];<br>float2 uvTR = textUv[index+<span class="hljs-number">1</span>];<br>float2 uvBL = textUv[index+<span class="hljs-number">2</span>];<br>float2 uvBR = textUv[index+<span class="hljs-number">3</span>];</pre><p></p><p>也就是说，只需要在CPU端根据DamageStyle和伤害数字就可以计算出在Shader中uv所处的下标位置。但伤害数字是由1到多位数组成，因此需要将数字每一位拆出来计算出每个数字的下标并设置到Entity的TextTRS.uvVexIdx中即可。</p><p></p><p>我们知道渲染一个字符需要4个顶点和uv，也就需要4个index读取，但TextTRS.uvVexIdx中只有16个uint，只能显示4个字符。这样是远远不能满足十万百万位数的伤害的，因此我们需要做一个字符压缩：</p><p></p><div class="media-wrap image-wrap"><img class="media-wrap image-wrap" alt="loading" title="UWA" src="//uwa-edu.oss-cn-beijing.aliyuncs.com/3.1729493106727.png" width="400px" style="width:400px"></div><p></p><p></p><h3>字符压缩原理</h3><p></p><p>一共有10*4+1（空格）= 41个字符，那么一共就有41*4=164个顶点和uv。164刚好算一个byte大小。</p><p></p><p>一个byte占8位，一个uint占32位，那么一个uint就可以储存4个byte。刚好就是一个字符所需要的index数量。</p><p></p><p>这样1个uint就可以表示1个字符，uint4*4就可以表示16个字符，最大可以表示千亿亿位数的伤害。</p><p></p><pre class="hljs C#">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">uint</span> <span class="hljs-title">PackUint4</span>(<span class="hljs-params">uint4 <span class="hljs-keyword">value</span></span>)</span><br>    {<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BitsPerValue = <span class="hljs-number">8</span>;<br> <br>        <span class="hljs-keyword">uint</span> combined = (<span class="hljs-keyword">value</span>.x &lt;&lt; (<span class="hljs-number">3</span> * BitsPerValue)) |<br>                        (<span class="hljs-keyword">value</span>.y &lt;&lt; (<span class="hljs-number">2</span> * BitsPerValue)) |<br>                        (<span class="hljs-keyword">value</span>.z &lt;&lt; (<span class="hljs-number">1</span> * BitsPerValue)) |<br>                        (<span class="hljs-keyword">value</span>.w &lt;&lt; (<span class="hljs-number">0</span> * BitsPerValue));<br>
                <span class="hljs-keyword">return</span> combined;<br>    }<br>
            <span class="hljs-function"><span class="hljs-keyword">public</span> uint4 <span class="hljs-title">UnpackUint4</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> <span class="hljs-keyword">value</span></span>)</span><br>    {<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BitsPerValue = <span class="hljs-number">8</span>;<br> <br>        <span class="hljs-keyword">uint</span> a = (<span class="hljs-keyword">value</span> &gt;&gt; (<span class="hljs-number">3</span> * BitsPerValue)) &amp; <span class="hljs-number">0xFF</span>;<br>        <span class="hljs-keyword">uint</span> b = (<span class="hljs-keyword">value</span> &gt;&gt; (<span class="hljs-number">2</span> * BitsPerValue)) &amp; <span class="hljs-number">0xFF</span>;<br>        <span class="hljs-keyword">uint</span> c = (<span class="hljs-keyword">value</span> &gt;&gt; (<span class="hljs-number">1</span> * BitsPerValue)) &amp; <span class="hljs-number">0xFF</span>;<br>        <span class="hljs-keyword">uint</span> d = (<span class="hljs-keyword">value</span> &gt;&gt; (<span class="hljs-number">0</span> * BitsPerValue)) &amp; <span class="hljs-number">0xFF</span>;<br>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uint4(a, b, c, d);<br>    }<br></pre><p></p><pre class="hljs C#">var packValue = PackUint4(<span class="hljs-keyword">new</span> uint4(<span class="hljs-number">2</span>, <span class="hljs-number">42</span>, <span class="hljs-number">81</span>, <span class="hljs-number">255</span>));<br>Debug.Log(packValue); <span class="hljs-comment">// 36327935</span><br>Debug.Log(UnpackUint4(packValue)); <span class="hljs-comment">// uint4(2, 42, 81, 255)</span></pre><p></p><p></p><h3>伤害最大值</h3><p></p><p>由于使用的是DrawMeshInstancedIndirect渲染，那么渲染时每个伤害的Mesh顶点和UV数量都要一致。因此需要在项目制定一个标准，约定好伤害的最大值，这里我设定伤害最大值为999999999，那么就是9个字符。经过上面的字符压缩，最大可以渲染16个字符，这样就不需要使用uint4*4表示了，使用uint3*3即可，这样也能节省一定的带宽。当只需要渲染2，3个字符时，可以使用空格字符填充补足9个字符所需的顶点。</p><p></p><h3>Shader解析渲染数据</h3><p></p><p>回顾最前面的Shader数据结构可以知道，textUvs和textVets储存了Font的所有字符uv和顶点，infoBuffer.uvVexIdx则储存着要渲染的伤害字符每个uv和顶点下标，因此只需要通过SV_VertexID结合uvVexIdx就可以算出对应的uv顶点值。</p><p></p><p>uvVexIdx经过字符压缩，最终的结构其实是：</p><p></p><p>* a b c | =&gt; | a0,a1,a2,a3 | b0,b1,b2,b3 | c0,c1,c2,c3</p><p>* d e f | =&gt; | d0,d1,d2,d3 | e0,e1,e2,e3 | f0,f1,f2,f3</p><p>* g h i | =&gt; | g0,g1,g2,g3 | h0,h1,h2,h3 | i0,i1,i2,i3</p><p></p><p>即一个12*3的矩阵。这样只需要将SV_VertexID解析到3*3矩阵的下标并读取值，通过解压缩字符算法解析出4个uv下标值，再将SV_VertexID解析出uv偏移下标值即可。</p><p></p><pre class="hljs C#">            <span class="hljs-function"><span class="hljs-keyword">uint</span> <span class="hljs-title">UnpackUint4</span>(<span class="hljs-params"><span class="hljs-keyword">uint</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">uint</span> idx</span>)</span><br>            {<br>                <span class="hljs-keyword">uint</span> a = (<span class="hljs-keyword">value</span> &gt;&gt; (idx * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">255</span>;<br>                <span class="hljs-keyword">return</span> a;<br>            }<br>
                        <span class="hljs-keyword">int</span> adv = v.vid/<span class="hljs-number">4</span>;<br>                <span class="hljs-keyword">int</span> ix = adv%<span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">int</span> iy = v.vid/<span class="hljs-number">12</span>;<br>                <span class="hljs-keyword">uint</span> idx4i = <span class="hljs-number">3</span>-v.vid%<span class="hljs-number">4</span>;<br>                <span class="hljs-keyword">uint</span> idx4 = idx3x3[iy][ix];<br>                <span class="hljs-keyword">uint</span> idx = UnpackUint4(idx4,idx4i);</pre><h3></h3><h3>创建伤害Entity</h3><p></p><p>要创建一个伤害渲染Entity主要参数有3个：世界坐标float2、伤害值int和伤害类型DamageStyle。</p><p></p><p>世界坐标直接将数据设置到TextTRS.wpos即可。</p><p></p><p>伤害值和伤害类型需要进行一个解析，将伤害每个数字解析出来并算出uv和顶点的index，进而写入到TextTRS.uvVexIdx中：</p><p></p><pre class="hljs C#">        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数字的位数的每个值</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="value"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="bits"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="dig"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        [<span class="hljs-meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintBits</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">ref</span> NativeArray&lt;<span class="hljs-keyword">int</span>&gt; bits, <span class="hljs-keyword">int</span> dig</span>)</span><br>        {<br>            <span class="hljs-keyword">int</span> i = dig - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (math.floor(<span class="hljs-keyword">value</span>) &gt; <span class="hljs-number">0</span>)<br>            {<br>                <span class="hljs-comment">// 提取最低位的十进制值</span><br>                <span class="hljs-keyword">int</span> digit = <span class="hljs-keyword">value</span> % <span class="hljs-number">10</span>;<br>                bits[i] = digit;<br>                <span class="hljs-comment">// 除以 10 来移除最低位的十进制值</span><br>                <span class="hljs-keyword">value</span> /= <span class="hljs-number">10</span>;<br>                i--;<br>            }<br>
                }<br>
                <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数字的位数</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="value"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        [<span class="hljs-meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberDigits</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><br>        {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : (<span class="hljs-keyword">int</span>)math.log10(<span class="hljs-keyword">value</span>) + <span class="hljs-number">1</span>;<br>        }<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> RENDER_CHAR_LENGTH = <span class="hljs-number">9</span>;<br>
            [<span class="hljs-meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetIndex</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> style, <span class="hljs-keyword">int</span> text, <span class="hljs-keyword">ref</span> uint3x3 index</span>)</span><br>    {<br>        <span class="hljs-keyword">var</span> dig = GetNumberDigits(text);<br>        NativeArray&lt;<span class="hljs-keyword">int</span>&gt; bits = <span class="hljs-keyword">new</span> NativeArray&lt;<span class="hljs-keyword">int</span>&gt;(dig, Allocator.Temp);<br>        PrintBits(text, <span class="hljs-keyword">ref</span> bits, dig);<br>        <span class="hljs-keyword">int</span> len = bits.Length;<br>        <span class="hljs-keyword">uint</span> empty = PackUint4(<span class="hljs-keyword">new</span> uint4(<span class="hljs-number">160</span>, <span class="hljs-number">161</span>, <span class="hljs-number">162</span>, <span class="hljs-number">163</span>)); <span class="hljs-comment">// 空格</span><br>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; RENDER_CHAR_LENGTH; i++)<br>        {<br>            <span class="hljs-keyword">int</span> x = i % <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">int</span> y = i / <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (len &gt; i)<br>            {<br>                <span class="hljs-keyword">uint</span> a = (<span class="hljs-keyword">uint</span>)(style * <span class="hljs-number">40</span> + bits[i] * <span class="hljs-number">4</span>);<br>                <span class="hljs-keyword">uint</span> b = a + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">uint</span> c = a + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">uint</span> d = a + <span class="hljs-number">3</span>;<br>                index[x][y] = PackUint4(<span class="hljs-keyword">new</span> uint4(a, b, c, d));<br>            }<br>            <span class="hljs-keyword">else</span><br>            {<br>                index[x][y] = empty;<br>            }<br>        }<br>    }<br>    <br>    <br>    [<span class="hljs-meta">BurstCompile</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> SystemState state</span>)</span><br>    {<br>
                <span class="hljs-keyword">var</span> elapsedTime = state.WorldUnmanaged.Time.ElapsedTime;<br>        <span class="hljs-comment">// if (elapsedTime &gt; _spawnInterval + _lastSpawnTime)</span><br>        <span class="hljs-comment">// {</span><br>            <span class="hljs-comment">// _lastSpawnTime = elapsedTime;</span><br>            <span class="hljs-keyword">var</span> cfg = SystemAPI.GetSingleton&lt;CombatTextConfig&gt;();<br> <br>            <span class="hljs-keyword">var</span> wpos = _random.NextFloat2(<span class="hljs-keyword">new</span> float2(<span class="hljs-number">-10f</span>,<span class="hljs-number">-5f</span>),<span class="hljs-keyword">new</span> float2(<span class="hljs-number">10f</span>,<span class="hljs-number">5f</span>));<br>            <span class="hljs-keyword">int</span> damage = _random.NextInt(<span class="hljs-number">999999999</span>);<br>            <span class="hljs-keyword">int</span> style = _random.NextInt(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br> <br> <br>            uint3x3 index = <span class="hljs-keyword">new</span> uint3x3();<br>            FontMeshHelper.SetIndex(style, damage, <span class="hljs-keyword">ref</span> index);<br> <br>            Entity entity =<br>                state.EntityManager.Instantiate(cfg.prefab);<br>            state.EntityManager.SetComponentData(entity, <span class="hljs-keyword">new</span> TextTRS<br>            {<br>                wpos = wpos,<br>                uvVexIdx = index,<br>                scale = <span class="hljs-keyword">new</span> float2(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>)<br>            });<br> <br>            state.EntityManager.SetComponentData(entity, <span class="hljs-keyword">new</span> DestroyTimer<br>            {<br>                fixedTime = elapsedTime,<br>                duration = <span class="hljs-number">20f</span>,<br>                autoDestroy = <span class="hljs-number">0</span><br>            });<br> <br>        <span class="hljs-comment">// }</span><br>    }</pre><p></p><h3>更新渲染数据</h3><p></p><pre class="hljs C#">public <span class="hljs-keyword">class</span> <span class="hljs-title">EntityDataManager</span> : <span class="hljs-title">MonoBehaviour</span><br>{<br>    <span class="hljs-keyword">public</span> EntityManager entityManager;<br>    <span class="hljs-keyword">public</span> World world;<br>
            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span><br>    {<br>        world = World.DefaultGameObjectInjectionWorld;<br>        entityManager = world.EntityManager;<br>    }<br>
            <span class="hljs-keyword">public</span> T GetData&lt;T&gt;(Entity entity) <span class="hljs-keyword">where</span> T : unmanaged, IComponentData<br>    {<br>        <span class="hljs-keyword">if</span> (HasComponent&lt;T&gt;(entity))<br>        {<br>            <span class="hljs-keyword">return</span> entityManager.GetComponentData&lt;T&gt;(entity);<br>        }<br>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">default</span>;<br>    }<br>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> SetData&lt;T&gt;(Entity entity, T data) <span class="hljs-keyword">where</span> T : unmanaged, IComponentData<br>    {<br>        <span class="hljs-keyword">if</span> (HasComponent&lt;T&gt;(entity))<br>        {<br>            entityManager.SetComponentData(entity, data);<br>        }<br>    }<br>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> HasComponent&lt;T&gt;(Entity entity) <span class="hljs-keyword">where</span> T : unmanaged, IComponentData<br>    {<br>        <span class="hljs-keyword">return</span> entityManager.HasComponent&lt;T&gt;(entity);<br>    }<br>
            <span class="hljs-keyword">readonly</span> Dictionary&lt;System.Type, EntityQuery&gt; _queryMap = <span class="hljs-keyword">new</span>();<br>
            <span class="hljs-keyword">public</span> NativeArray&lt;T&gt; GetAllData&lt;T&gt;(Allocator allocator = Allocator.Temp)<br>        <span class="hljs-keyword">where</span> T : unmanaged, IComponentData<br>    {<br>        EntityQuery entityQuery;<br>        <span class="hljs-keyword">if</span> (!_queryMap.TryGetValue(<span class="hljs-keyword">typeof</span>(T), <span class="hljs-keyword">out</span> entityQuery))<br>        {<br>            entityQuery = entityManager.CreateEntityQuery(<span class="hljs-keyword">typeof</span>(T));<br>            _queryMap.Add(<span class="hljs-keyword">typeof</span>(T), entityQuery);<br>        }<br>
                <span class="hljs-keyword">return</span> entityQuery.ToComponentDataArray&lt;T&gt;(allocator);<br>    }<br>}<br>
            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params"></span>)</span><br>    {<br>        UpdateBuffer();<br>        Graphics.DrawMeshInstancedIndirect(mesh, <span class="hljs-number">0</span>, material,<br>            bounds: renderBounds,<br>            bufferWithArgs: argsBuffer,<br>            argsOffset: <span class="hljs-number">0</span>,<br>            properties: propertyBlock,<br>            castShadows: ShadowCastingMode.Off,<br>            receiveShadows: <span class="hljs-literal">false</span>,<br>            layer: layer);<br>    }<br>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateBuffer</span>(<span class="hljs-params"></span>)</span><br>    {<br>        <span class="hljs-keyword">var</span> buffer = entityDataManager.GetAllData&lt;TextTRS&gt;();<br>        infoBuffer.SetData(buffer);<br>
                _currentRenderCount = (<span class="hljs-keyword">uint</span>)buffer.Length;<br>        args[<span class="hljs-number">1</span>] = _currentRenderCount;<br>        argsBuffer.SetData(args);<br>    }</pre><p></p><h3>伤害数字动画效果</h3><p></p><p>动画效果无非就是改变坐标和缩放数据，这个可以在System Job里实现，也可以用Compute Shader/Shader里实现。</p><p></p><pre class="hljs C#">        [<span class="hljs-meta">BurstCompile</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> SystemState state</span>)</span><br>        {<br>            state.Dependency = <span class="hljs-keyword">new</span> PlayCombatTextJob()<br>            {<br>                elapsedTime = SystemAPI.Time.ElapsedTime,<br>                dt = SystemAPI.Time.DeltaTime<br>            }.ScheduleParallel(_entityQuery, state.Dependency);<br>        }<br>
                [<span class="hljs-meta">BurstCompile</span>]<br>        <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> PlayCombatTextJob : IJobEntity<br>        {<br>            [<span class="hljs-meta">ReadOnly</span>] <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> elapsedTime;<br>            [<span class="hljs-meta">ReadOnly</span>] <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> dt;<br>
                    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> Timer timer, <span class="hljs-keyword">ref</span> TextTRS info, <span class="hljs-keyword">ref</span> LocalTransform transform</span>)</span><br>            {<br>                <span class="hljs-keyword">float</span> startScale = <span class="hljs-number">2f</span>;<br>                <span class="hljs-keyword">float</span> endScale = <span class="hljs-number">1f</span>;<br>                <span class="hljs-keyword">float</span> lifeTime = <span class="hljs-number">0.8f</span>;<br>                <span class="hljs-keyword">float</span> d = (<span class="hljs-keyword">float</span>)(elapsedTime - timer.fixedTime);<br>                <span class="hljs-keyword">float</span> x = d / (lifeTime * <span class="hljs-number">0.5f</span>);<br>                <span class="hljs-keyword">var</span> scaleTime = EasingFunctions.Ease(EaseType.ElasticOut, x);<br>                <span class="hljs-keyword">var</span> posEaseValue = EasingFunctions.Ease(EaseType.Linear, x) * dt;<br>
                        transform.Scale = scaleTime;<br>                info.wpos += <span class="hljs-keyword">new</span> float2(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) * posEaseValue;<br>                info.scale = startScale + scaleTime * (endScale - startScale);<br>                <span class="hljs-comment">//new float2(scaleTime);</span><br>            }<br>        }</pre><p></p><p>这里使用dots-tween做缓动动画：<a href="https://github.com/dyonng/dots-tween" target="_blank">dyonng/dots-tween: Tween library for Unity ECS/DOTS. (github.com)</a></p><p></p><h3>性能测试</h3><p></p><div class="media-wrap video-wrap"><video controls="" class="media-wrap video-wrap" title="UWA" src="https://videos2.uwa4d.com/4.1729493505727.mp4" controlslist="nodownload"></video></div><p></p><p>在我的设备上测试8w个渲染数据依旧能跑120帧。</p><p></p><p>配置：</p><p></p><p>CPU：13th Gen Intel(R) Core(TM) i7-13700KF</p><p></p><p>GPU：AMD Radeon RX 6800 XT</p><p></p><p></p><p></p><p></p></div><!----></div>
</body>
</html>