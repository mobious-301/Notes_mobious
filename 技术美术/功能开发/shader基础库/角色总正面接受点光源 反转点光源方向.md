è¦å®ç° **â€œè§’è‰²æ€»æ˜¯æ­£é¢ç…§äº®â€** çš„æ•ˆæœï¼ˆå³æ— è®ºç¯å…‰åœ¨å“ªä¸ªæ–¹å‘ï¼Œæ³•çº¿å§‹ç»ˆæœå‘å…‰æºï¼‰ï¼ŒåŒæ—¶é¿å…ä½¿ç”¨ `if` è¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨ **æ³•çº¿åè½¬æŠ€æœ¯** ç»“åˆ **ç¯å…‰æ–¹å‘è®¡ç®—**ã€‚ä»¥ä¸‹æ˜¯ä¼˜åŒ–åçš„ä»£ç ï¼š

---

### **1. æ ¸å¿ƒæ€è·¯**
- **è®¡ç®—æ³•çº¿æ–¹å‘**ï¼šæ ¹æ®ç¯å…‰æ–¹å‘åŠ¨æ€è°ƒæ•´æ³•çº¿ï¼Œä½¿å…¶å§‹ç»ˆæœå‘å…‰æºã€‚
- **é¿å…åˆ†æ”¯ï¼ˆ`if`ï¼‰**ï¼šä½¿ç”¨ `step` æˆ– `sign` ç­‰æ— åˆ†æ”¯å‡½æ•°ã€‚

---

### **2. ä¿®æ”¹åçš„ `ProcessLightLambert` å‡½æ•°**
```hlsl
half3 ProcessLightLambert(InputData inputData, half4 shadowMask, uint meshRenderingLayers, int lightIndex)
{
    // è·å–ç¯å…‰æ•°æ®
    #if defined(_ADDITIONAL_LIGHT_SHADOWS) && !defined(_RECEIVE_SHADOWS_OFF)
    Light light = GetAdditionalLight(lightIndex, inputData.positionWS, shadowMask);
    #else
    Light light = GetAdditionalLight(lightIndex, inputData.positionWS);
    #endif

    #ifdef USE_LIGHT_LAYERS
    if (!IsMatchingLightLayer(light.layerMask, meshRenderingLayers))
        return half3(0, 0, 0);
    #endif

    // è®¡ç®—è¡°å‡
    half3 attenuation = (light.distanceAttenuation * light.shadowAttenuation);
    half3 attenuatedLightColor = light.color * saturate(attenuation + _ShadowAddtive) * 0.2;

    // æ ¸å¿ƒé€»è¾‘ï¼šåŠ¨æ€åè½¬æ³•çº¿ï¼Œä½¿è§’è‰²æ€»æ˜¯æ­£é¢ç…§äº®
    float3 normalWS = inputData.normalWS;
    float3 lightDir = light.direction;
    
    // åˆ¤æ–­ç¯å…‰æ˜¯å¦åœ¨è§’è‰²åæ–¹ï¼ˆdot(N,L) < 0ï¼‰
    half isBackLit = step(0, dot(normalWS, lightDir)); // 0=åæ–¹ï¼Œ1=å‰æ–¹
    half3 adjustedNormal = lerp(-normalWS, normalWS, isBackLit); // åæ–¹æ—¶åè½¬æ³•çº¿

    // ä½¿ç”¨è°ƒæ•´åçš„æ³•çº¿è®¡ç®—å…‰ç…§
    #ifndef _DIFFUSE_RAMP
    return LightingLambert(attenuatedLightColor, lightDir, adjustedNormal);
    #else
    return LightingLambertRamped(light.color, attenuation, lightDir, adjustedNormal);
    #endif
}
```

---

### **3. å…³é”®ä¼˜åŒ–ç‚¹**
1. **æ— åˆ†æ”¯æ³•çº¿åè½¬**  
   - ç”¨ `dot(normalWS, lightDir)` åˆ¤æ–­ç¯å…‰æ˜¯å¦åœ¨åæ–¹ã€‚
   - ç”¨ `step(0, dot)` ç”Ÿæˆ `0` æˆ– `1` çš„æ©ç ï¼ˆæ—  `if`ï¼‰ã€‚
   - ç”¨ `lerp` æ··åˆåŸå§‹æ³•çº¿å’Œåè½¬æ³•çº¿ã€‚

2. **æ€§èƒ½ä¼˜åŠ¿**  
   - é¿å… GPU åˆ†æ”¯ï¼ˆ`if`ï¼‰ï¼Œæå‡ç€è‰²å™¨æ‰§è¡Œæ•ˆç‡ã€‚
   - `step` å’Œ `lerp` æ˜¯ç¡¬ä»¶å‹å¥½çš„æ“ä½œã€‚

---

### **4. æ‰©å±•ï¼šæ›´å¹³æ»‘çš„è¿‡æ¸¡**
å¦‚æœå¸Œæœ›ç¯å…‰åœ¨ **ä¾§é¢æ—¶å¹³æ»‘è¿‡æ¸¡**ï¼ˆè€Œéç¡¬æ€§åè½¬ï¼‰ï¼Œå¯ä»¥ç”¨ `smoothstep` æˆ– `sign`ï¼š
```hlsl
// å¹³æ»‘è¿‡æ¸¡ç‰ˆæœ¬
half backLitFactor = dot(normalWS, lightDir);
half smoothBlend = saturate(backLitFactor * 10.0); // è°ƒæ•´ç³»æ•°æ§åˆ¶è¿‡æ¸¡èŒƒå›´
half3 adjustedNormal = lerp(-normalWS, normalWS, smoothBlend);
```

---

### **5. åº”ç”¨åœºæ™¯**
- **è§’è‰²æ¸²æŸ“**ï¼šç¡®ä¿è§’è‰²åœ¨ä»»ä½•ç¯å…‰æ–¹å‘ä¸‹éƒ½èƒ½è¢«ç…§äº®ã€‚
- **é£æ ¼åŒ–æ¸²æŸ“**ï¼šå¡é€šæ¸²æŸ“ï¼ˆCel Shadingï¼‰ä¸­å¸¸ç”¨çš„â€œæ— å½±â€æ•ˆæœã€‚
- **æ€§èƒ½æ•æ„Ÿåœºæ™¯**ï¼šç§»åŠ¨ç«¯æˆ– VR ä¸­é¿å…åˆ†æ”¯ã€‚

---

### **6. æ³¨æ„äº‹é¡¹**
- **æ³•çº¿å½’ä¸€åŒ–**ï¼šç¡®ä¿ `normalWS` å’Œ `lightDir` æ˜¯å½’ä¸€åŒ–çš„å‘é‡ã€‚
- **é˜´å½±å…¼å®¹**ï¼šåè½¬æ³•çº¿åï¼Œé˜´å½±è®¡ç®—å¯èƒ½éœ€é¢å¤–å¤„ç†ï¼ˆå¦‚ä¿æŒåŸå§‹æ³•çº¿è®¡ç®—é˜´å½±ï¼‰ã€‚

è¿™æ ·å³å¯å®ç° **æ— åˆ†æ”¯ã€é«˜æ€§èƒ½çš„â€œæ€»æ˜¯æ­£é¢ç…§äº®â€æ•ˆæœ**ï¼ ğŸ¨