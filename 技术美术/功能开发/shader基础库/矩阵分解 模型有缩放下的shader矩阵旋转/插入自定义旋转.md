ä½ å·²ç»å¾ˆå¥½åœ°åˆ†è§£äº† Unity çš„ `unity_ObjectToWorld` çŸ©é˜µï¼Œå¹¶æå–å‡ºäº† **ç¼©æ”¾ï¼ˆScaleï¼‰ã€æ—‹è½¬ï¼ˆRotationï¼‰å’Œå¹³ç§»ï¼ˆTranslationï¼‰**ã€‚ç°åœ¨æˆ‘ä»¬æ¥è¡¥å…¨æ•´ä¸ªæµç¨‹ï¼Œå®ç°ä¸€ä¸ª **å®Œå…¨ä½¿ç”¨è¿™ä¸‰ä¸ªåˆ†é‡ä»£æ›¿åŸå§‹çŸ©é˜µè¿›è¡Œç©ºé—´å˜æ¢çš„å®Œæ•´è¿‡ç¨‹**ã€‚

æˆ‘ä»¬å°†æŒ‰ç…§æ ‡å‡†å˜æ¢é¡ºåºï¼š

> **å±€éƒ¨ç©ºé—´ â†’ ç¼©æ”¾ â†’ æ—‹è½¬ â†’ å¹³ç§» â†’ ä¸–ç•Œç©ºé—´**

---

## âœ… ç›®æ ‡ï¼šç”¨åˆ†è§£å‡ºçš„ `scale`ã€`rotation`ã€`translation` æ›¿ä»£ `unity_ObjectToWorld`

### ğŸ§  åŸç†å›é¡¾

Unity çš„ `unity_ObjectToWorld` æ˜¯ä¸€ä¸ª 4x4 å˜æ¢çŸ©é˜µï¼Œå®ƒå°è£…äº†ç‰©ä½“ä»å±€éƒ¨ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´çš„æ‰€æœ‰å˜æ¢ä¿¡æ¯ã€‚ä½†æœ‰æ—¶æˆ‘ä»¬éœ€è¦å¯¹è¿™äº›å˜æ¢è¿›è¡Œç‹¬ç«‹æ§åˆ¶ï¼Œä¾‹å¦‚ï¼š

- éå‡åŒ€ç¼©æ”¾ä¿®æ­£
- è‡ªå®šä¹‰æ—‹è½¬æ’å€¼
- åŠ¨æ€ä¿®æ”¹å¹³ç§»åç§»
- æ³•çº¿/åˆ‡çº¿å˜æ¢ç­‰

å› æ­¤æˆ‘ä»¬å°†å…¶æ‹†è§£ä¸ºä¸‰éƒ¨åˆ†ï¼Œå†æ‰‹åŠ¨ç»„åˆåº”ç”¨ã€‚

---

## ğŸ›  å®ç°æ­¥éª¤ï¼ˆä»¥é¡¶ç‚¹ç€è‰²å™¨ä¸ºä¾‹ï¼‰

ä»¥ä¸‹ä»£ç åœ¨ HLSL ä¸­å®ç°ï¼Œé€‚ç”¨äº Unity Shader Graph æˆ–è‡ªå®šä¹‰ Surface Shader / Unlit Shaderã€‚

---

### 1. åˆ†è§£å‡½æ•°ï¼ˆå·²æä¾›ï¼‰

```hlsl
float3 ExtractScale(float4x4 m) {
    return float3(
        length(float3(m._11, m._21, m._31)),
        length(float3(m._12, m._22, m._32)),
        length(float3(m._13, m._23, m._33))
    );
}

float3x3 ExtractRotationMatrix(float4x4 m) {
    float3 scale = ExtractScale(m);
    return float3x3(
        float3(m._11, m._21, m._31) / scale.x,
        float3(m._12, m._22, m._32) / scale.y,
        float3(m._13, m._23, m._33) / scale.z
    );
}

float3 ExtractTranslation(float4x4 m) {
    return float3(m._14, m._24, m._34);
}
```

---

### 2. åœ¨é¡¶ç‚¹å‡½æ•°ä¸­ä½¿ç”¨åˆ†è§£åçš„å˜é‡

```hlsl
struct Attributes {
    float4 positionOS : POSITION;
    float3 normalOS   : NORMAL;
};

struct Varyings {
    float4 positionCS : SV_POSITION;
    float3 normalWS   : TEXCOORD0;
    float3 worldPos   : TEXCOORD1;
};

Varyings vert(Attributes input) {
    Varyings output;

    // Step 1: åˆ†è§£ unity_ObjectToWorld
    float3 scale = ExtractScale(unity_ObjectToWorld);
    float3x3 rotation = ExtractRotationMatrix(unity_ObjectToWorld);
    float3 translation = ExtractTranslation(unity_ObjectToWorld);

    // Step 2: æ‰‹åŠ¨åº”ç”¨å˜æ¢é¡ºåºï¼šScale â†’ Rotate â†’ Translate
    float3 localPos = input.positionOS.xyz;
    float3 scaledPos = localPos * scale;
    float3 rotatedPos = mul(rotation, scaledPos);
    float3 worldPos = rotatedPos + translation;

    // Step 3: è½¬æ¢åˆ°è£å‰ªç©ºé—´ï¼ˆView Ã— Projectionï¼‰
    output.positionCS = mul(UNITY_MATRIX_VP, float4(worldPos, 1.0));

    // Step 4: æ³•çº¿å˜æ¢ï¼ˆåªç”¨æ—‹è½¬éƒ¨åˆ†å³å¯ï¼‰
    output.normalWS = mul(rotation, input.normalOS);

    // è¾“å‡ºä¸–ç•Œåæ ‡ç”¨äºåç»­æ•ˆæœï¼ˆå¦‚ GodRayã€å…‰ç…§è®¡ç®—ï¼‰
    output.worldPos = worldPos;

    return output;
}
```

---

### âœ… å¯¹æ¯”åŸå§‹æ–¹å¼ï¼ˆä»…ä½œå‚è€ƒï¼‰

ä¼ ç»Ÿåšæ³•æ˜¯ç›´æ¥ä½¿ç”¨ `mul(unity_ObjectToWorld, input.positionOS)`ï¼Œä½†ç°åœ¨æˆ‘ä»¬å®ç°äº†æ›´ç²¾ç»†çš„æ§åˆ¶ã€‚

---

## ğŸ” è¿›é˜¶æŠ€å·§

### A. æ”¯æŒè´Ÿç¼©æ”¾ï¼ˆé•œåƒç¿»è½¬ï¼‰

å¦‚æœä½ çš„æ¨¡å‹æœ‰è´Ÿç¼©æ”¾ï¼ˆå¦‚ scaleX = -1ï¼‰ï¼Œé‚£ä¹ˆä¸Šé¢çš„æ—‹è½¬å¯èƒ½ä¼šé”™è¯¯åœ°åè½¬æ–¹å‘ã€‚

#### æ£€æµ‹å¹¶ä¿®å¤é•œåƒç¿»è½¬ï¼š

```hlsl
// è®¡ç®—è¡Œåˆ—å¼ç¬¦å·åˆ¤æ–­æ˜¯å¦å‘ç”Ÿé•œåƒ
float matrixDeterminantSign = sign(determinant(unity_ObjectToWorld));
if (matrixDeterminantSign < 0) {
    rotation[2] *= -1; // ç¿»è½¬Zè½´ï¼ˆå³æ‰‹ç³» â†’ å·¦æ‰‹ç³»ï¼‰
}
```

---

### B. ä½¿ç”¨å››å…ƒæ•°æ›¿ä»£æ—‹è½¬çŸ©é˜µï¼ˆå¯é€‰ï¼‰

å¦‚æœä½ æƒ³ç”¨å››å…ƒæ•°åšæ’å€¼æˆ–åŠ¨ç”»æ··åˆï¼Œå¯ä»¥å…ˆæå–æ—‹è½¬å››å…ƒæ•°ï¼š

```hlsl
float4 ExtractRotationQuaternion(float4x4 m) {
    float3 scale = ExtractScale(m);
    float3x3 rotMat = float3x3(
        float3(m._11, m._21, m._31) / scale.x,
        float3(m._12, m._22, m._32) / scale.y,
        float3(m._13, m._23, m._33) / scale.z
    );

    float4 q;
    float trace = rotMat._11 + rotMat._22 + rotMat._33;
    if (trace > 0) {
        float s = sqrt(trace + 1.0) * 2;
        q.w = 0.25 * s;
        q.x = (rotMat._32 - rotMat._23) / s;
        q.y = (rotMat._13 - rotMat._31) / s;
        q.z = (rotMat._21 - rotMat._12) / s;
    } else if ((rotMat._11 > rotMat._22) && (rotMat._11 > rotMat._33)) {
        float s = sqrt(1.0 + rotMat._11 - rotMat._22 - rotMat._33) * 2;
        q.w = (rotMat._32 - rotMat._23) / s;
        q.x = 0.25 * s;
        q.y = (rotMat._12 + rotMat._21) / s;
        q.z = (rotMat._13 + rotMat._31) / s;
    } else if (rotMat._22 > rotMat._33) {
        float s = sqrt(1.0 + rotMat._22 - rotMat._11 - rotMat._33) * 2;
        q.w = (rotMat._13 - rotMat._31) / s;
        q.x = (rotMat._12 + rotMat._21) / s;
        q.y = 0.25 * s;
        q.z = (rotMat._23 + rotMat._32) / s;
    } else {
        float s = sqrt(1.0 + rotMat._33 - rotMat._11 - rotMat._22) * 2;
        q.w = (rotMat._21 - rotMat._12) / s;
        q.x = (rotMat._13 + rotMat._31) / s;
        q.y = (rotMat._23 + rotMat._32) / s;
        q.z = 0.25 * s;
    }
    return normalize(q);
}

// å››å…ƒæ•° â†’ å‘é‡å˜æ¢
float3 quat_rotate(float4 q, float3 v) {
    float3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}
```

ç„¶ååœ¨é¡¶ç‚¹å‡½æ•°ä¸­ï¼š

```hlsl
float4 q = ExtractRotationQuaternion(unity_ObjectToWorld);
float3 rotatedPos = quat_rotate(q, scaledPos);
```

---

## ğŸ“Œ æ€»ç»“

| æ­¥éª¤ | å†…å®¹ |
|------|------|
| âœ… æå–ç¼©æ”¾ | `ExtractScale()` |
| âœ… æå–æ—‹è½¬ | `ExtractRotationMatrix()` æˆ– `ExtractRotationQuaternion()` |
| âœ… æå–å¹³ç§» | `ExtractTranslation()` |
| âœ… åº”ç”¨é¡ºåº | `Scale â†’ Rotate â†’ Translate` |
| âœ… æ›¿ä»£çŸ©é˜µ | `mul(unity_ObjectToWorld, pos)` â†’ `rotate(scale * pos) + translate` |
| âš ï¸ æ³¨æ„äº‹é¡¹ | éå‡åŒ€ç¼©æ”¾ã€é•œåƒç¿»è½¬ã€æ€§èƒ½ä¼˜åŒ– |

---

## ğŸ§ª åº”ç”¨åœºæ™¯ä¸¾ä¾‹

- **GodRay / å…‰æŸ±ç‰¹æ•ˆ**ï¼šéœ€è¦æ ¹æ®ç‰©ä½“æœå‘è°ƒæ•´å°„çº¿æ–¹å‘ã€‚
- **ç²’å­ç³»ç»Ÿ**ï¼šæ ¹æ®å¯¹è±¡æ—‹è½¬ç¼©æ”¾å‘å°„æ–¹å‘ã€‚
- **åŠ¨æ€å˜å½¢**ï¼šä¿®æ”¹å±€éƒ¨ç¼©æ”¾æˆ–æ—‹è½¬åé‡æ–°æ„å»ºçŸ©é˜µã€‚
- **éª¨éª¼åŠ¨ç”»é‡å®šå‘**ï¼šæ‰‹åŠ¨æ§åˆ¶æ—‹è½¬ä¸ç¼©æ”¾ã€‚

---

å¦‚æœä½ æœ‰å…·ä½“åº”ç”¨åœºæ™¯ï¼ˆæ¯”å¦‚ `GodRay` å¦‚ä½•ä½¿ç”¨è¿™ä¸ªç»“æ„ï¼‰ï¼Œæˆ‘å¯ä»¥ç»§ç»­å¸®ä½ å®Œå–„å¯¹åº”é€»è¾‘å’Œä»£ç ç¤ºä¾‹ã€‚æ¬¢è¿ç»§ç»­æé—®ï¼