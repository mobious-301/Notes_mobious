要从 Unity 的模型矩阵（`unity_ObjectToWorld`）中提取 **缩放（Scale）、旋转（Rotation）和平移（Translation）** 分量，需要使用 **矩阵分解（Matrix Decomposition）** 技术。以下是具体方法和代码实现：

---

## **1. 矩阵分解原理**
Unity 的 `unity_ObjectToWorld` 是一个 `4x4` 变换矩阵，结构如下：
```
| X轴缩放及旋转 | Y轴缩放及旋转 | Z轴缩放及旋转 | 平移 |
|---------------|---------------|---------------|------|
| m00 m01 m02   | m03           | (通常为0)     | m03  |
| m10 m11 m12   | m13           | (通常为0)     | m13  |
| m20 m21 m22   | m23           | (通常为0)     | m23  |
| 0   0   0     | 1             |               |      |
```
我们需要分解出：
1. **缩放（Scale）**：计算各轴向量长度。
2. **旋转（Rotation）**：正交化处理，提取旋转矩阵或四元数。
3. **平移（Translation）**：直接取最后一列。

---

## **2. 代码实现（HLSL）**
### **(1) 提取缩放（Scale）**
```hlsl
float3 ExtractScale(float4x4 m) {
    return float3(
        length(float3(m._11, m._21, m._31)), // X轴缩放
        length(float3(m._12, m._22, m._32)), // Y轴缩放
        length(float3(m._13, m._23, m._33))  // Z轴缩放
    );
}
```
**说明**：
- 计算每个轴基向量的长度，得到 `(scaleX, scaleY, scaleZ)`。
- 如果存在 **负缩放**（如镜像翻转），可以用 `sign(dot(cross(x,y),z))` 判断是否需要取反。

---

### **(2) 提取旋转（Rotation）**
#### **方法1：提取旋转矩阵（3x3）**
```hlsl
float3x3 ExtractRotationMatrix(float4x4 m) {
    float3 scale = ExtractScale(m);
    return float3x3(
        float3(m._11, m._21, m._31) / scale.x, // 归一化X轴
        float3(m._12, m._22, m._32) / scale.y, // 归一化Y轴
        float3(m._13, m._23, m._33) / scale.z  // 归一化Z轴
    );
}
```
**说明**：
- 先提取缩放，再对旋转部分进行归一化。
- 适用于需要 **直接使用旋转矩阵** 的情况（如变换法线）。

#### **方法2：转换为四元数（Quaternion）**
```hlsl
// 旋转矩阵 → 四元数（适用于插值或存储）
float4 ExtractRotationQuaternion(float4x4 m) {
    float3 scale = ExtractScale(m);
    float3x3 rotMat = float3x3(
        float3(m._11, m._21, m._31) / scale.x,
        float3(m._12, m._22, m._32) / scale.y,
        float3(m._13, m._23, m._33) / scale.z
    );
    
    // 转换为四元数
    float4 q;
    q.w = sqrt(max(0, 1 + rotMat._11 + rotMat._22 + rotMat._33)) / 2;
    q.x = sqrt(max(0, 1 + rotMat._11 - rotMat._22 - rotMat._33)) / 2;
    q.y = sqrt(max(0, 1 - rotMat._11 + rotMat._22 - rotMat._33)) / 2;
    q.z = sqrt(max(0, 1 - rotMat._11 - rotMat._22 + rotMat._33)) / 2;
    q.x = copysign(q.x, rotMat._32 - rotMat._23);
    q.y = copysign(q.y, rotMat._13 - rotMat._31);
    q.z = copysign(q.z, rotMat._21 - rotMat._12);
    return normalize(q);
}
```
**说明**：
- 适用于需要 **平滑插值旋转** 的情况（如动画）。
- 比矩阵更节省空间（`float4` vs `float3x3`）。

---

### **(3) 提取平移（Translation）**
```hlsl
float3 ExtractTranslation(float4x4 m) {
    return float3(m._14, m._24, m._34); // 直接取最后一列的前三个分量
}
```
**说明**：
- 平移信息直接存储在矩阵的最后一列（`m._14_24_34`）。

---

## **3. 完整示例（Shader 中使用）**
```hlsl
// 定义矩阵分解函数
float3 ExtractScale(float4x4 m) { /* 同上 */ }
float3x3 ExtractRotationMatrix(float4x4 m) { /* 同上 */ }
float3 ExtractTranslation(float4x4 m) { /* 同上 */ }

// 在顶点着色器中使用
Varyings vert(Attributes input) {
    Varyings output;
    
    // 提取变换分量
    float3 scale = ExtractScale(unity_ObjectToWorld);
    float3x3 rotation = ExtractRotationMatrix(unity_ObjectToWorld);
    float3 translation = ExtractTranslation(unity_ObjectToWorld);

    // 手动应用变换（顺序：缩放 → 旋转 → 平移）
    float3 worldPos = mul(rotation, input.positionOS.xyz * scale) + translation;
    output.positionCS = mul(UNITY_MATRIX_VP, float4(worldPos, 1.0));

    // 法线变换（使用逆转置矩阵，或直接旋转）
    output.normalWS = mul(rotation, input.normalOS);

    return output;
}
```

---

## **4. 注意事项**
1. **非均匀缩放的影响**  
   - 如果物体有非均匀缩放（如 `(2,1,1)`），直接提取的旋转矩阵可能包含 **扭曲**，需额外处理。
2. **层级缩放问题**  
   - `unity_ObjectToWorld` 包含 **所有父级变换**，如需局部变换，应使用 `unity_ObjectToWorld` 的逆矩阵。
3. **性能优化**  
   - 如果矩阵不变（如静态物体），可在 CPU 端计算并通过 `MaterialPropertyBlock` 传递。

---

## **5. 总结**
| 分量      | 提取方法                          | 适用场景                |
|-----------|----------------------------------|-----------------------|
| **缩放**  | `length(axis)`                   | 非均匀缩放修正          |
| **旋转**  | 归一化行列 → 矩阵/四元数          | 法线变换/插值          |
| **平移**  | 直接取 `m._14_24_34`              | 世界坐标计算           |

这种方法可以精确控制 **缩放、旋转、平移** 的分离与重组，适用于高级 Shader 特效（如你的 `GodRay` 旋转修正）。