### **代码功能概述**
这段 **HLSL 像素着色器** 主要用于 **后处理特效**，结合 **深度缓冲** 和 **多纹理混合** 来实现 **景深模糊（Depth of Field, DoF）** 和 **雾效（Fog）**，最终输出到屏幕。  

---

## **1. 输入与采样**
### **纹理（Texture2D）**
- **`t0` (tex0)**：基础颜色（720p，可能是场景渲染的原始颜色）
- **`t1` (tex1)**：深度缓冲（720p，存储像素的深度值）
- **`t2` (tex2)**：混合纹理（640×760，可能是模糊后的颜色或某种特效）
- **`t3` (tex3)**：雾气/粒子效果（720p，可能是体积光、雾或弥散圆效果）

### **采样器（SamplerState）**
- `s0_s` ~ `s3_s` 分别对应 `t0` ~ `t3` 的采样方式（如线性过滤、点采样等）。

### **常量缓冲区（cbuffer）**
- **`cb0`**：存储全局参数（如模糊强度、雾效参数等）
- **`cb1`**：存储深度计算相关的参数（如景深范围、焦点位置等）

---

## **2. 深度计算（核心部分）**
### **(1) 从 `t1` 读取深度**
```hlsl
r0.xy = cb0[29].zw * v1.xy;  // 计算 UV 坐标（可能用于动态调整采样位置）
r0.z = t1.SampleLevel(s1_s, r0.xy, 0).x;  // 采样深度值（0~1 范围）
```
- `v1.xy` 是屏幕空间坐标（SV_POSITION）。
- `cb0[29].zw` 可能是 UV 缩放参数（如动态分辨率适配）。

### **(2) 计算非线性深度**
```hlsl
r0.w = r0.z * cb1[65].z + -cb1[65].w;  // 线性变换（可能是从 NDC 到观察空间）
r0.z = r0.z * cb1[65].x + cb1[65].y;   // 另一种深度计算方式
r0.w = 1 / r0.w;                       // 计算倒数（可能是透视校正）
r0.z = r0.z + r0.w;                    // 混合两种深度计算方式
```
- 这里可能是在 **转换深度值**，使其更适合 **景深计算**（如从 Z-Buffer 转换为观察空间深度）。

### **(3) 计算景深模糊权重**
```hlsl
r0.w = -cb1[154].z + r0.z;             // 计算与焦平面的距离
r0.w = -cb1[155].y + r0.w;             // 调整模糊范围
r0.w = max(0, r0.w);                   // 确保非负
r0.w = cb1[154].z + r0.w;              // 重新调整模糊强度
r1.x = cmp(cb1[154].z < r0.z);         // 判断是否在焦外
r0.z = r1.x ? r0.w : r0.z;             // 选择模糊程度
```
- **`cb1[154].z`** 可能是 **焦平面（Focal Plane）** 的深度。
- **`cb1[155].y`** 可能是 **模糊范围（Blur Radius）** 的调整参数。
- 最终 `r0.z` 存储 **模糊权重**（离焦平面越远，权重越大）。

### **(4) 计算最终混合系数**
```hlsl
r0.z = 9.99999975e-006 * r0.z;         // 归一化深度值
r0.w = cb1[154].z * 9.99999975e-006 + -r0.z;  // 计算模糊强度
r1.x = cb1[155].x * cb1[154].w;        // 调整模糊强度
r0.w = r1.x * r0.w;                    // 应用模糊强度
r1.x = cb1[154].z * 9.99999975e-006 + -cb1[155].x;  // 计算反向权重
r0.z = r1.x * r0.z;                    // 反向混合
r0.z = r0.w / r0.z;                    // 计算最终混合系数
r0.z = min(1, abs(r0.z));              // 限制在 [0, 1] 范围
r0.z = 5 * r0.z;                       // 增强模糊效果（5 倍强度）
r0.z = min(1, r0.z);                   // 再次限制
r0.z = 1 + -r0.z;                      // 反转权重（1 - blurFactor）
```
- 最终 `r0.z` 是 **模糊混合系数**：
  - **`0`** → 完全模糊
  - **`1`** → 完全不模糊（清晰）

---

## **3. 颜色混合**
### **(1) 采样 `t2`（模糊后的颜色）**
```hlsl
r2.xyzw = t2.Sample(s3_s, v0.xy).xyzw;  // 采样模糊纹理
r0.w = max(0.00100000005, r2.w);        // 避免除零
r2.xyz = r2.xyz / r0.www;               // 归一化颜色（可能是 HDR 处理）
```
- `t2` 可能是 **高斯模糊后的场景颜色**（用于景深模糊）。

### **(2) 采样 `t0`（原始颜色）**
```hlsl
r3.xyz = t0.Sample(s0_s, r0.xy).xyz;    // 采样原始颜色
```
- `t0` 是 **未模糊的场景颜色**。

### **(3) 混合模糊和清晰颜色**
```hlsl
r0.w = saturate(cb0[27].w * r2.w);      // 计算模糊权重
r2.xyz = -r3.xyz + r2.xyz;              // 计算颜色差值
r1.xyz = r0.www * r2.xyz + r3.xyz;      // 线性插值（模糊 + 清晰）
```
- `cb0[27].w` 可能是 **全局模糊强度**。

### **(4) 应用深度模糊**
```hlsl
r2.xyz = r3.xyz + -r1.xyz;              // 计算颜色差值
r2.w = 1;                               // Alpha = 1
r0.xyzw = r0.zzzz * r2.xyzw + r1.xyzw;  // 应用深度模糊（r0.z 是模糊权重）
```
- **`r0.z` 越小，模糊越强**（因为 `1 - blurFactor` 被用于混合）。

---

## **4. 垂直模糊（增强景深效果）**
```hlsl
r1.x = v0.x;                            // 保持 X 坐标
r1.y = cb0[28].y + v0.y;                // 偏移 Y 坐标（模拟垂直模糊）
r1.xyzw = t2.Sample(s3_s, r1.xy).xyzw;  // 采样模糊纹理（偏移后）
r2.x = max(0.00100000005, r1.w);        // 避免除零
r2.xyz = r1.xyz / r2.xxx;               // 归一化颜色
r1.x = saturate(cb0[27].w * r1.w);      // 计算模糊权重
r2.w = 0;                               // Alpha = 0
r2.xyzw = r2.xyzw + -r0.xyzw;           // 计算颜色差值
r0.xyzw = r1.xxxx * r2.xyzw + r0.xyzw;  // 混合垂直模糊
```
- **`cb0[28].y`** 控制 **垂直模糊偏移量**（模拟镜头散景效果）。

---

## **5. 最终雾效合成**
```hlsl
r1.xyz = r3.xyz + -r0.xyz;              // 计算颜色差值
r0.xyz = r0.www * r1.xyz + r0.xyz;      // 调整 Alpha 混合
r4.xyzw = t3.Sample(s2_s, r0.xy).xyzw;  // 采样雾气/粒子纹理
o0.xyz = r0.xyz * r4.www + r4.xyz;      // 混合雾效（基于雾的 Alpha）
o0.w = 0;                               // 输出 Alpha = 0（不透明）
```
- **`t3`（雾气/粒子）** 可能是 **体积光、雾或镜头光晕**。
- 最终颜色 = **模糊后的颜色 × 雾气 Alpha + 雾气颜色**。

---

## **总结**
### **核心效果**
1. **景深模糊（DoF）**：
   - 基于深度缓冲计算模糊权重。
   - 混合 `t0`（清晰）和 `t2`（模糊）纹理。
2. **垂直模糊**：
   - 模拟镜头散景（Bokeh）效果。
3. **雾效/粒子**：
   - 使用 `t3` 添加雾气或光晕效果。

### **用途**
- 可能是 **电影化渲染（Cinematic Rendering）** 的一部分。
- 适用于 **开放世界游戏** 的远景模糊 + 雾效。
- 也可以用于 **摄影模式** 的景深模拟。

### **优化点**
- **`t2` 分辨率较低（640×760）** → 可能用于性能优化（模糊不需要高分辨率）。
- **深度计算较复杂** → 可能是为了适应不同摄像机参数（如焦距、光圈）。

这段代码展示了 **现代游戏后处理的核心技术**，适合学习 **HLSL 高级渲染技巧**！ 🚀