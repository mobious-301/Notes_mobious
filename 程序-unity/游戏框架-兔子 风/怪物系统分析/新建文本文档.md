让我分析一下让 TestEnemyBH 直接运行需要的修改：

### 1. 必要组件添加

```csharp
// TestEnemyBH 需要的基础组件
1. BehaviorTree - AI行为树组件
2. PropertyComp - 属性组件
3. SpineRendererComp - 渲染组件
4. Collider - 碰撞器组件
5. Rigidbody - 刚体组件
6. UnitStateController - 状态控制器
```

### 2. 初始化流程修改

```csharp
public class TestEnemyBH : BaseEnemy 
{
    // 添加必要的序列化字段
    [SerializeField] private int objId;  // 对象ID
    [SerializeField] private int dataId;  // 数据ID
    
    // 添加初始化方法
    private void Awake()
    {
        // 1. 确保有必要组件
        if (!TryGetComponent<BehaviorTree>(out var bt))
        {
            bt = gameObject.AddComponent<BehaviorTree>();
        }
        if (!TryGetComponent<Rigidbody>(out var rb))
        {
            rb = gameObject.AddComponent<Rigidbody>();
            rb.constraints = RigidbodyConstraints.FreezeRotation;  // 锁定旋转
        }
        if (!TryGetComponent<CapsuleCollider>(out var col))
        {
            col = gameObject.AddComponent<CapsuleCollider>();
        }

        // 2. 添加必要的组件
        var propertyComp = new PropertyComp();
        compDict.Add(typeof(PropertyComp), propertyComp);
        
        var meshActComp = new SpineRendererComp();
        compDict.Add(typeof(SpineRendererComp), meshActComp);
    }

    private void Start()
    {
        // 手动调用初始化链
        OnInit();
        OnSpawn();
    }
}
```

### 3. 配置数据模拟

```csharp
// 添加配置数据模拟类
public class MockConfigManager 
{
    public static Dictionary<string, object> GetMockUnitConfig(int id)
    {
        var propertyMap = new Dictionary<string, object>
        {
            {"Hp", 100},
            {"PhyAttack", 10},
            {"MagAttack", 10},
            {"PhyDef", 5},
            {"MagDef", 5},
            {"Piercing", 0},
            {"Tough", 100}
        };

        return new Dictionary<string, object>
        {
            {"type", 0},  // 0普通，1精英，2BOSS
            {"propertyMap", propertyMap}
        };
    }
}

// 修改 InitializeEnemyProperty 方法
public void InitializeEnemyProperty(int id)
{
    // 获取模拟配置
    var config = MockConfigManager.GetMockUnitConfig(id);
    var propertyMap = (Dictionary<string, object>)config["propertyMap"];

    var propertyComp = TryGetComp<PropertyComp>();
    if (propertyComp == null) return;

    // 设置基础属性
    propertyComp.SetStaticValue(EnumProperty.MaxHp.GetHashCode(), (int)propertyMap["Hp"]);
    propertyComp.SetStaticValue(EnumProperty.CurHp.GetHashCode(), (int)propertyMap["Hp"]);
    propertyComp.SetStaticValue(EnumProperty.PhyAttack.GetHashCode(), (int)propertyMap["PhyAttack"]);
    propertyComp.SetStaticValue(EnumProperty.MagAttack.GetHashCode(), (int)propertyMap["MagAttack"]);
    propertyComp.SetStaticValue(EnumProperty.PhyDefense.GetHashCode(), (int)propertyMap["PhyDef"]);
    propertyComp.SetStaticValue(EnumProperty.MagDefense.GetHashCode(), (int)propertyMap["MagDef"]);
}
```

### 4. 行为树配置

```csharp
// 添加基础行为树配置
private void SetupBehaviorTree()
{
    var bt = GetComponent<BehaviorTree>();
    if (bt == null) return;

    // 设置基础变量
    bt.SetVariableValue("unitStateController", unitStateController);
    bt.SetVariableValue("unit", this);
    bt.SetVariableValue("targetPos", Vector3.positiveInfinity);
    bt.StartWhenEnabled = true;
    bt.RestartWhenComplete = true;

    // 这里需要添加一个基础的行为树资源
    // bt.ExternalBehavior = 你的行为树资源
}
```

### 5. 状态机设置

```csharp
// 添加基础状态机设置
private void SetupStateController()
{
    if (unitStateController == null)
    {
        unitStateController = gameObject.AddComponent<UnitStateController>();
    }

    // 添加基础状态
    var aiChaseState = new AIChaseState(this);
    var aiGoToState = new AIGoToState(this);
    var showState = new UnitShowState(this);
    var idleState = new UnitIdleState(this);
    var jumpingState = new UnitJumpingState(this);
    var onHitState = new UnitOnHitState(this);
    var onDieState = new UnitOnDieState(this);
    var attackingState = new UnitAttackingState(this);
    var castingState = new UnitCastingState(this);

    unitStateController.ResetStateList(new BaseUnitState[]
    {
        aiChaseState, aiGoToState, idleState, jumpingState, onHitState, 
        onDieState, attackingState, castingState, showState
    });
}
```

### 6. 事件系统注册

```csharp
// 添加必要的事件监听
private void RegisterEvents()
{
    EventManager.Instance.AddListener<int>(EventId.OnPropertyMapChanged, OnPropertyMapChanged);
    EventManager.Instance.AddListener<int>(EventId.OnStatusMapChanged, OnStatusMapChanged);
    EventManager.Instance.AddListener<int, int, int, int>(EventId.OnHit, OnHit);
}

private void UnregisterEvents()
{
    EventManager.Instance.RemoveListener<int>(EventId.OnPropertyMapChanged, OnPropertyMapChanged);
    EventManager.Instance.RemoveListener<int>(EventId.OnStatusMapChanged, OnStatusMapChanged);
    EventManager.Instance.RemoveListener<int, int, int, int>(EventId.OnHit, OnHit);
}
```

### 7. 预制体设置

创建一个新的预制体，包含以下设置：

1. 基础GameObject结构：
```
- EnemyRoot (TestEnemyBH)
  |- Model (包含渲染相关组件)
  |- Collider (碰撞器)
```

2. 组件配置：
```yaml
TestEnemyBH:
  - objId: 设置对象ID
  - dataId: 设置数据ID
  - BehaviorTree: 配置基础行为树
  - Rigidbody: 
      - Mass: 1
      - Drag: 适当的阻力
      - UseGravity: true
      - Constraints: FreezeRotation
  - CapsuleCollider:
      - Radius: 适当的碰撞半径
      - Height: 适当的碰撞高度
```

### 8. 运行时注册

```csharp
// 在适当的地方添加到 BattleManager
void AddToBattleManager()
{
    if (BattleManager.Instance != null)
    {
        BattleManager.Instance.enemyList.Add(this);
        // 如果需要立即进入战斗状态
        BattleManager.Instance.battleEnemyList.Add(this);
    }
}
```

### 9. 完整的启动流程

```csharp
public class TestEnemyBH : BaseEnemy 
{
    private void Awake()
    {
        SetupComponents();
    }

    private void Start()
    {
        // 初始化链
        OnInit();
        SetupStateController();
        SetupBehaviorTree();
        RegisterEvents();
        
        // 生成
        OnSpawn();
        InitializeEnemyProperty(dataId);
        AddToBattleManager();
    }

    private void OnDestroy()
    {
        UnregisterEvents();
    }
}
```

### 注意事项：

1. **资源依赖**：
   - 确保所有需要的动画资源可用
   - 确保行为树资源可用
   - 确保所有需要的预制体资源可用

2. **配置数据**：
   - 如果没有配置系统，需要硬编码或者创建临时的配置数据
   - 确保所有必要的配置值都有合理的默认值

3. **组件依赖**：
   - 检查所有需要的组件是否都正确添加
   - 确保组件之间的依赖关系正确

4. **事件系统**：
   - 确保事件系统正常工作
   - 正确处理事件的注册和注销

5. **性能考虑**：
   - 添加适当的距离检查逻辑
   - 添加适当的优化标记

这些修改应该能让 TestEnemyBH 直接运行，但可能还需要根据具体项目的需求进行调整。建议在测试环境中逐步添加这些功能，确保每个部分都正常工作后再整合到一起。
